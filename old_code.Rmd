

# All old code no longer being used - archiving to see where mistakes were made...!

# Variable/Wavelength Selection & PLS on __length__ as a test
Using temp_proc df produced from quickproc() function above.  VIP score to select wavelengths that are most informative to model

```{r}
quickproc(scan_avg,1,3,17) # SG of scan_avg DF to genereate temp_proc df for models below

test_pls_length <- pls(temp_proc[, 21:ncol(temp_proc)], temp_proc[, 2],
  scale = T, center = F, info = "Length Prediction Model",
  cv = 1
)
saveRDS(test_pls_length, "RDS_dataframes/PLS_Length")

# pls only with wavenumebrs VIP > 1
length_VIP <- vipscores(test_pls_length) # extract VIP values for wavenumbers of above pls model
plotVIPScores(test_pls_length)
test_waves <- names(subset(length_VIP[,1], length_VIP[,1] > 1)) 
all_waves <- names(temp_proc[,21:length(temp_proc)])
bad_waves <- all_waves[!(all_waves %in% test_waves)]
test_pls_length_VIP <- pls(temp_proc[,21:ncol(temp_proc)], temp_proc[,2],
  scale = T, center = F, info = "Length Prediction Model",
  exclcols = bad_waves,
  cv = 1
)
saveRDS(test_pls_length_VIP, "RDS_dataframes/PLS_Length_VIP")

# unprocessed df PLS
test_pls_length_unproc <- pls(scan_avg[, 21:ncol(scan_avg)], scan_avg[, 2],
  scale = T, center = F, info = "Length Prediction Model",
  cv = 1
)
saveRDS(test_pls_length_unproc, "RDS_dataframes/PLS_Length_unproc")

# 90% train, 10% test PLS, no VIP
set.seed(1)
idx <- floor(nrow(temp_proc) * 0.9)
train_idx <- sample(seq_len(nrow(temp_proc)), size = idx)
train <- temp_proc[train_idx, -c(1,3:20)]
test <- temp_proc[-train_idx, -c(1,3:20)]
test_pls_length_split <- pls(train[,-c(1)], train[,1],
  scale = T, center = F,
  info = "Length Prediction Model", cv = 1,
  x.test = test[,-c(1)], y.test = test[,1]
)
saveRDS(test_pls_length_split, "RDS_dataframes/PLS_Length_split")

# 90% train, 10% test PLS, VIP
test_pls_length_split_VIP <- pls(train[,-c(1)], train[,1],
  scale = T, center = F,
  info = "Length Prediction Model", cv = 1,
  x.test = test[,-c(1)], y.test = test[,1],
  exclcols = bad_waves
)
saveRDS(test_pls_length_split_VIP, "RDS_dataframes/PLS_Length_split_VIP")

plot(test_pls_length)
plot(test_pls_length_VIP)
plot(test_pls_length_unproc)
plot(test_pls_length_split)
plot(test_pls_length_split_VIP)

test_pls_length$res$cal$rmse[2]
test_pls_length_VIP$res$cal$rmse[3]
test_pls_length_unproc$res$cal$rmse[3]
test_pls_length_split$res$test$rmse[2]
test_pls_length_split_VIP$res$test$rmse[3]

rm(test_pls_length, test_pls_length_VIP, test_pls_length_unproc, test_pls_length_split, test_pls_length_split_VIP)
rm(test,train,length_VIP, all_waves, bad_waves, idx, test_waves, train_idx)
```



# PCR for age

```{r}
quickproc(age_only,1,3,17)
pca_age_LPW <- pca(temp_proc[21:ncol(temp_proc)], scale = T)
plot(pca_age_LPW)
mlr_age_pcs <- pca_age_LPW$calres$scores[,1:10]
mlr_age_pcs <- cbind(mlr_age_pcs, temp_proc[,1:11])
mlr_age <- lm(data = mlr_age_pcs, read_age ~ `Comp 1` + `Comp 2` + `Comp 3` + `Comp 4` + `Comp 5`)
summary(mlr_age)

# MLR with split
set.seed(1)
idx <- floor(nrow(age_only) * 0.9) # 90% of indices needed for training set
train_idx <- sample(seq_len(nrow(age_only)), size = idx) # generate indices for training set
train <- mlr_age_pcs[train_idx, -c(11:20)] # wavenumber measurement columns only
test <- mlr_age_pcs[-train_idx, -c(11:20)]
mlr_age_split <- lm(data = train, read_age ~`Comp 1` + `Comp 2` + `Comp 3` + `Comp 4` + `Comp 5`)
summary(mlr_age_split)
mlr_age_split_pred <- predict(mlr_age_split,test)
ggplot() +  # fitted values vs actual, out of sample prediction in red
  geom_point(aes(train$read_age,mlr_age_split$fitted.values)) + 
  geom_point(aes(test$read_age,mlr_age_split_pred),col = "red") + 
  geom_abline(slope=1, intercept = 0, col = "red")

# Split for PCR
set.seed(1)
idx <- floor(nrow(temp_proc) * 0.9)
train_idx <- sample(seq_len(nrow(temp_proc)), size = idx)
train <- age_only[train_idx, -c(1:10,12:20)] 
test <- age_only[-train_idx, -c(1:10,12:20)] 

pcr_age_model <- pcr(read_age ~ .,
                 data = train, 
                 scale = T,
                 validation = "CV",
                 ncomp = 10)
selectNcomp(pcr_age_model, "onesigma", plot = TRUE) # determine appropriate number of comps
scoreplot(pcr_age_model) # plot of first 2 PCs

pcr_age_pred <- predict(pcr_age_model, newdata = test, ncomp = 4) # fit model to test data, store fitted values
ggplot() +
  geom_point(aes(x = train$read_age, y = pcr_age_model$fitted.values[, , 4])) + # extract fitted values of model with 2 PCs.
  geom_point(aes(x = test$read_age, y = pcr_age_pred), col = "red") +
  geom_abline(slope = 1, col = "red")

RMSEP(pcr_age_model)


```


# PCR & PC GAMs using length

This code is no longer relevant; I was incorrectly applying the PCA prior to splitting dataset.
```{r}

# extract PC's
pca_LPW <- pca(scan_avg[21:ncol(scan_avg)], scale = T) # PCA for scan_avg
plot(pca_LPW)
pca_LPW <- pca_LPW$calres$scores[, 1:20] # extract PCs
pca_LPW <- cbind(pca_LPW[, 1:10], scan_avg[, 1:20]) # only store first 10 PC's
colnames(pca_LPW)[c(1:10)] <- c("PC1", "PC2", "PC3", "PC4", "PC5","PC6", "PC7", "PC8", "PC9", "PC10")

# PCR
PCR_length <- lm(data = pca_LPW, length ~ PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10)
summary(PCR_length) # some PC's seem less informative than others
PCR_length2 <- update(PCR_length, length ~ PC1 + PC2 + PC5 + PC6 + PC8 + PC10)
summary(PCR_length2)
plot(PCR_length)
plot(PCR_length2)


PCR_length3 <- pcr(length ~ ., data = scan_avg[,c(2,21:ncol(scan_avg))], ncomp = 20,
                   validation = "CV")
selectNcomp(PCR_length3, "onesigma", plot = TRUE) # determine appropriate number of comps, suggested 4
scoreplot(PCR_length3) # plot of first 2 PCs


PCR_length3$fitted.values[,,4]


set.seed(1)
inTraining <- createDataPartition(scan_avg$length, p = .9, list = F)
training <- scan_avg[inTraining,-c(1,3:20)]
testing  <- scan_avg[-inTraining,-c(1,3:20)]
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           ## repeated ten times
                           repeats = 10,
                           preProcOptions = list(pcaComp = 10))
PCR_length4 <- train(length ~ ., data = training, 
                 method = "lm", 
                 trControl = fitControl,
                 preProcess = "pca")
PCR_length4$
scan_avg[inTraining,-c(1,3:20)]

pca <- prcomp(scan_avg[inTraining,-c(1:20)],center=F,scale=T)
pca$rotation
pca$sdev
pca_LPW$PC1
dim(pca_LPW1$x)
pca_LPW1$loadings
testing1 <- preProcess(scan_avg[inTraining,-c(1:20)], method = "pca", pcaComp = 10)
predict(testing1, scan_avg[inTraining,-c(1,3:ncol(scan_a))])


postResampleSpectro(predict(PCR_length4,testing),testing$length)
PCR_length4
pcr1
PCR_length4$finalModel






# PCR with 10-fold split for RMSE
set.seed(1)
splits <- caret::createFolds(pca_LPW$length, k = 10, list = TRUE, returnTrain = FALSE)
PCR_errors <- vector()
# GAM
for(i in 1:10){
  mod <- lm(data = pca_LPW[-splits[[i]],], length ~ PC1 + PC2 + PC3 + PC4 + PC5 + PC6 + PC7 + PC8 + PC9 + PC10)
  preds <- predict(mod, newdata = pca_LPW[splits[[i]],])
  PCR_errors[i] <- RMSE(pca_LPW[splits[[i]],]$length, preds)
}
# RMSE
mean(PCR_errors)

# PCR with only significant PC's from lm() summary
for(i in 1:10){
  mod <- lm(data = pca_LPW[-splits[[i]],], length ~ PC1 + PC2 + PC5 + PC6 + PC8 + PC10)
  preds <- predict(mod, newdata = pca_LPW[splits[[i]],])
  PCR_errors2[i] <- RMSE(pca_LPW[splits[[i]],]$length, preds)
}
#RMSE
mean(PCR_errors2)

# choosing the best PC's for length results in lowest RMSE

pred <- predict(PCR_length2,pca_LPW[splits[[1]],])
ggplot() +  # fitted values vs actual, out of sample prediction in red
  geom_point(aes(pca_LPW[splits[[1]],]$length,PCR_length2$fitted.values)) + 
  geom_point(aes(test$length,PCR_length_split_pred),col = "red") + 
  geom_abline(slope=1, intercept = 0, col = "red")

# Split for PCR
set.seed(1)
idx <- floor(nrow(scan_avg) * 0.9) # 90% of indices needed for training set
train_idx <- sample(seq_len(nrow(scan_avg)), size = idx) # generate indices for training set
train <- scan_avg[train_idx, -c(1, 3:20)] # length and wavenumber measurement columns only
test <- scan_avg[-train_idx, -c(1, 3:20)]

# PCR model 
pcr_length_model <- pls::pcr(length ~ .,
  data = train,
  scale = T,
  validation = "CV",
  ncomp = 10
) # look at 10 components max
selectNcomp(pcr_length_model, "onesigma", plot = TRUE) # determine appropriate number of comps
scoreplot(pcr_length_model) # plot of first 2 PCs
loadingplot(pcr_length_model)

pcr_length_pred <- predict(pcr_length_model, newdata = test, ncomp = 2) # fit model to test data, store fitted values
ggplot() +
  geom_point(aes(x = train$length, y = pcr_length_model$fitted.values[, , 2])) + # extract fitted values of model with 2 PCs.
  geom_point(aes(x = test$length, y = pcr_length_pred), col = "red") +
  geom_abline(slope = 1, col = "red")

```

# PLS for Age

```{r}
# df with only aged specimens
age_only <- scan_avg[complete.cases(scan_avg$read_age),]

# test pls, no variable selection
test_pls_age <- pls(age_only[, 21:ncol(age_only)], age_only[, 11],
  scale = F, center = T, info = "Age Prediction Model",
  cv = 1
)
plot(test_pls_age)
# pls with VIP > 1
test_vip_age <- vipscores(test_pls_age)
plotVIPScores(test_pls_age)
good_waves <- as.numeric(names(subset(test_vip_age[,1], test_vip_age[,1] > 1)))
all_waves <- names(age_only[,21:length(age_only)])
bad_waves <- all_waves[!(all_waves %in% good_waves)]

test_pls_age_VIP <- pls(age_only[, 21:ncol(age_only)], age_only[, 11],
 scale = F, center = T, info = "Age Prediction Model",
 cv = 1, exclcols = bad_waves
)

# 90/10 split for PLS, no VIP
set.seed(1)
idx <- floor(nrow(age_only) * 0.9)
train_idx <- sample(seq_len(nrow(age_only)), size = idx)
train <- age_only[train_idx, -c(1:10,12:20)]
test <- age_only[-train_idx, -c(1:10,12:20)]

test_pls_age_split <- pls(train[,-1], train[,1],
  scale = F, center = T,
  info = "Age Prediction Model", cv = 1,
  x.test = test[,-1], y.test = test[,1]
)

# 90/10 split for PLS, VIP > 1
test_pls_age_split_VIP <- pls(train[,-1], train[,1],
  scale = F, center = T,
  info = "Age Prediction Model", cv = 1,
  x.test = test[,-c(1)], y.test = test[,1],
  exclcols = bad_waves
)

plot(test_pls_age)
plot(test_pls_age_VIP)
plot(test_pls_age_split)
plot(test_pls_age_split_VIP)

test_pls_age$res$cal$rmse[3]
test_pls_age_VIP$res$cal$rmse[2]
test_pls_age_split$res$test$rmse[3]
test_pls_age_split_VIP$res$cal$rmse[2]
```

# Other unorganized code

```{r}
pca_LPW <- pca(scan_avg_filter[,31:ncol(scan_avg_filter)], scale = F, center = T)
plot(pca_LPW)
plotVariance(pca_LPW$res$cal, type = "h", show.labels = TRUE, labels = "values")
# MDAtools PCA match prcomp output
pca_LPW$calres$scores[,1]
scan_avg_filter[,1]

data(simdata)
Xc = simdata$spectra.c
Xt = simdata$spectra.t
m = pca(Xc, 7, x.test = Xt)

PCA_res <- list()
PCA_test <- list()
for (i in 1:10) {
  Xc = scan_avg_filter[-splits[[i]], 31:ncol(scan_avg_filter)]
  Xt = scan_avg_filter[splits[[i]], 31:ncol(scan_avg_filter)]
  test_pca <- pca(Xc, scale = F, center = T, x.test = Xt)
  PCA_res[[i]] <- test_pca$calres$scores[,1:5]
  PCA_test[[i]] <- test_pca$testres$scores[,1:5]
}

# pca and pcares
lm(data=scan_avg_filter, length ~ )


plot(testing)
testing$testres

# PCR 
set.seed(1)
inTraining <- createDataPartition(scan_avg_filter$length, p = .9, list = F)
training <- scan_avg_filter[inTraining,-c(11,13:30)]
testing  <- scan_avg_filter[-inTraining,-c(11,13:30)]
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           ## repeated ten times
                           repeats = 10)
pcr1 <- train(length ~ ., data = training, 
                 method = "pcr", 
                 trControl = fitControl)
pcr1$results
# RMSE for predictions
RMSE(predict(pcr1,testing),testing$length)
pcr1


# PLS
set.seed(1)
inTraining <- createDataPartition(scan_avg$length, p = .9, list = F)
training <- scan_avg[inTraining,-c(1,3:20)]
testing  <- scan_avg[-inTraining,-c(1,3:20)]
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           ## repeated ten times
                           repeats = 10)
pls1 <- train(length ~ ., data = training,
              method = "widekernelpls",
              trControl = fitControl,
             )
pls1
postResampleSpectro(predict(pls1,testing),testing$length)


# PLS
set.seed(1)
inTraining <- createDataPartition(scan_avg$length, p = .9, list = F)
training <- scan_avg[inTraining,-c(1,3:20)]
testing  <- scan_avg[-inTraining,-c(1,3:20)]
fitControl <- trainControl(## 10-fold CV
                           method = "repeatedcv",
                           number = 10,
                           ## repeated ten times
                           repeats = 10)
pls2 <- train(x = scan_avg[,21:ncol(scan_avg)],
              y = scan_avg$length,
              method = "pls", 
              tuneLength = 6)
pls2
postResampleSpectro(predict(pls2,testing),testing$length)


##### NOW WITH MY DOGSHIT AGES ###### 

# 10 fold CV split, GAMS for age with RMSE
set.seed(1)
splits <- caret::createFolds(mlr_age_pcs$length, k = 10, list = TRUE, returnTrain = FALSE)
gam_errors <- vector()
mean(gam_errors)
# GAM
for(i in 1:10){
  mod <- gam(data = pca_LPW[-splits[[i]],], length ~ s(PC1) + s(PC2) + s(PC3) + s(PC4) + s(PC5), method="REML", select = T)
  preds <- predict(length_gam, newdata = pca_LPW[splits[[i]],])
  gam_errors[i] <- RMSE(pca_LPW[splits[[i]],]$length, preds)
}
#RMSE
mean(gam_errors)





PCR_length_split_pred <- predict(PCR_length_split,test)
ggplot() +  # fitted values vs actual, out of sample prediction in red
  geom_point(aes(train$length,PCR_length_split$fitted.values)) + 
  geom_point(aes(test$length,PCR_length_split_pred),col = "red") + 
  geom_abline(slope=1, intercept = 0, col = "red")







pca_LPW <- pca(scan_avg_rem[21:ncol(scan_avg)], scale = T) # PCA for scan_avg
plot(pca_LPW)
pca_LPW <- pca_LPW$calres$scores[, 1:20] # extract PCs
pca_LPW <- cbind(pca_LPW[, 1:5], scan_avg[, 1:4]) # only store first 5 PC's
colnames(pca_LPW)[c(1:5)] <- c("PC1", "PC2", "PC3", "PC4", "PC5")
PCR_length <- lm(data = pca_LPW, length ~ PC1 + PC2 + PC3 + PC4 + PC5)
summary(PCR_length) # only appear to need first 2 comps
PCR_length <- update(PCR_length, length ~ PC1 + PC2)
summary(PCR_length)


test <- AIC.summary %>% group_by(model) %>% summarise(meanAIC = mean(AIC),
                                              meanAICc = mean(AICc))
test


```


